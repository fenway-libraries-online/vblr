#!/usr/bin/perl

use strict;
use warnings;

sub usage;
sub warning;
sub fatal;

use MARC::Loop qw(marcloop marcfield TAG DELETE VALREF);
use IPC::Run qw(run);
use Getopt::Long
    qw(:config posix_default gnu_compat require_order bundling no_ignore_case);

my ($root, $dbfile);
my %env = read_environment();

my (%project, %file, %record, %fields, %matches, %results);

@ARGV = qw(shell) if !@ARGV;
my $cmd = shift @ARGV;
$cmd =~ tr/-/_/;
my $sub = __PACKAGE__->can("cmd_$cmd") || usage;
$sub->();

# --- Command handlers

sub cmd_dbi {
    readopts();
    system('sqlite3', $dbfile);
}

sub cmd_auto {
    env('root');
    subcmd();
}

sub cmd_auto_trace {
    readopts();
    my ($p, $u, $b) = env(qw(project update batch));
    $b =~ /^([1-9][0-9]*)-([1-9][0-9]*)$/ or die "unrecognized batch: $b";
    my $n = $1;
    my $tag = '997';
    marcloop {
        my ($leader, $fields) = @_;
        $_->[DELETE] = 1 for grep { $_->[TAG] eq $tag } @$fields;
        push @$fields, marcfield(
            $tag, ' ', ' ',
                p => $p,
                f => $u,
                n => $n++,
        );
    } \*STDIN, 'print_all' => 1, 'error' => sub { die };
}

sub cmd_auto_hook {
    my ($h) = env('hook');
    unshift @ARGV, $h if !@ARGV || $ARGV[0] =~ /^-/;
    subcmd();
}

sub cmd_auto_hook_added {
    my ($add_records, $add_matches) = (0, 0);
    readopts(
        'r|add-records' => \$add_records,
        'm|add-matches' => \$add_matches,
    );
    $add_records = 1 if $add_matches;
    my ($r, $p, $u, $purpose) = env(qw(root project update purpose));
    my ($f, $added) = pfr_add_file($r, $p, $u, $purpose);
    pfr_add_records($p, $u, $f) if $add_records;
    pfr_add_matches($p, $u, $f) if $add_matches;
}

sub cmd_auto_hook_prepared {
    my ($add_records, $add_matches, $added, $matched) = (1, 1, 0, 0);
    readopts(
        'R|no-add-records' => sub { $add_records = 0 },
        'M|no-add-matches' => sub { $add_matches = 0 },
    );
    $add_records = 1 if $add_matches;
    my ($r, $p, $u, $b, $purpose) = env(qw(root project update batch purpose));
    $b =~ /^([1-9][0-9]*)-([1-9][0-9]*)$/ or fatal "unrecognized batch: $b";
    my ($s, $e) = ($1, $2);
    my ($f) = glob("$r/$p/updates/$u/batches/$b/records.mrc")
        or fatal "no MARC file for batch $b of update $u in project $p";
    pfr_add_records($p, $u, $f, $s) if $add_records;
    pfr_add_matches($p, $u, $f, $s) if $add_matches;
}

sub cmd_auto_hook_loaded {
    readopts();
    my ($r, $p, $u, $b, $j, $purpose) = env(qw(root project update batch job purpose));
    my $jid = pfr_add_job($r, $p, $u, $b, $j, $purpose);
    my $res = pfr_add_results($r, $p, $u, $b, $j);
}

# --- pfr invocations

sub pfr_add_file {
    my ($r, $p, $u, $purpose) = @_;
    my ($f) = glob("$r/$p/updates/$u/*.mrc")
        or fatal "no MARC file for update $u in project $p";
    (my $fbase = $f) =~ s{.+/}{};
    my $fid;
    run(pfrcmd('add file', "pkey:$p", "fkey=$u", "name=$fbase", "purpose=$purpose"), \$fid)
        or fatal "exec pfr add file: $?";
    chomp $fid;
    return wantarray ? ($f, $fid) : $f;
}

sub pfr_add_records {
    my ($p, $u, $f, $s) = @_;
    $s ||= 1;
    my $n;
    run([qw(marc2pfr -o -n), $s], '<', $f, '|', pfrcmd('add records', "pkey:$p", "fkey:$u"), \$n)
        or fatal "exec pfr add records: $?";
    chomp $n;
    return $n;
}

sub pfr_add_matches {
    my ($p, $u, $f, $s) = @_;
    $s ||= 1;
    my $n;
    run([qw(marc2pfr -o -n), $s], '<', $f, '|', pfrcmd('add matches', "pkey:$p", "fkey:$u"), \$n)
        or fatal "exec pfr add matches: $?";
    chomp $n;
    return $n;
}

sub pfr_add_job {
    my ($r, $p, $u, $b, $j, $purpose) = @_;
    my $jdir = "$r/$p/updates/$u/batches/$b/jobs/$j";
    -d $jdir or fatal "no job $j for batch $b of update $u in project $p";
    my $jid;
    run(pfrcmd('add job', "pkey:$p", "fkey:$u", "jkey=$j", "purpose=$purpose"), \$jid)
        or fatal "exec pfr add job: $?";
    chomp $jid;
    return $jid;
}

sub pfrcmd {
    my $cmd = shift;
    return [ 'pfr', split(/\s+/, $cmd), '-z', '-d' => $dbfile, @_ ];
}

# --- Other functions

sub readopts {
    $root = eval { env('root') };
    $dbfile = $ENV{'VBDB_FILE'};
    GetOptions(
        'r|root=s' => \$root,
        'd|db-file=s' => \$dbfile,
    ) or usage;
    $dbfile ||= $root . '/' . 'vbdb.sqlite';
}

sub subcmd {
    usage if !@ARGV;
    my $subcmd = shift @ARGV;
    my @caller = caller 1;
    $caller[3] =~ /(cmd_\w+)$/ or die;
    goto &{ __PACKAGE__->can($1.'_'.$subcmd) || usage };
}

sub read_environment {
    my %e;
    while (my ($k, $v) = each %ENV) {
        next if $k !~ s/^VBLR_//;
        $e{lc $k} = $v;
    }
    return %e;
}

sub env {
    my @e;
    foreach (@_) {
        my $k = 'VBLR_' . uc $_;
        die "environment variable not set: $k" if !defined $ENV{$k};
        push @e, $ENV{$k};
    }
    return @e if wantarray;
    return \@e if @_ > 1;
    return $e[0];
}

sub optenv {
    my @e;
    foreach (@_) {
        my $k = 'VBLR_' . uc $_;
        push @e, $ENV{$k};
    }
    return @e;
}

sub usage {
    print STDERR "usage: vbdb COMMAND [ARG...]\n";
    exit 1;
}

sub fatal {
    print STDERR "vbdb: ", shift(), "\n";
    print STDERR $_, "\n" for @_;
    exit 2;
}
